{
  "hash": "8ff52ae8f7ca31151fe167a85f62a2c5",
  "result": {
    "markdown": "---\ntitle: \"QRM Case Study: Visa\"\nauthor: \"Juan Quinonez\"\ndate: \"2022-11-19\"\ncategories: [economics, GARCH, analysis]\ndraft: false\neditor: visual\n---\n\n\nEl siguiente análisis es motivado a raíz del curso de Quantitative Risk Management impartido por [Stefan Bolta](https://rpubs.com/whitenoise1), organizado por el [Instituto de Finanzas de Santo Domingo](https://ifisd.com/quienessomos/quienes-somos/).\n\n## QRM\n\nUno de los objetivos de un Gerente de Riesgo Cuantitativo (QRM) es medir y monitorear el riesgo de un portafolio. Para esta tarea se utiliza la **volatilidad** de los rendimientos del portafolio como medida de riesgo.\n\nEn este análisis se exploran diferentes medidas de volatilidad utilizando los retornos de las acciones de la compañía Visa para el período comprendido entre 2008 y 2021.\n\n**Medidas de Volatilidad**\n\n-   No condicional vs condicional\n\n-   Exponentially weighted moving average (EWMA)\n\n-   GARCH\n\n## Visa\n\nPara este caso estaremos utilizando la serie de precios de Visa desde el 2008 hasta el 2021. Más abajo se muestra la evolución de los retornos diarios de este instrumento.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(quantmod)\nlibrary(PerformanceAnalytics)\nlibrary(rugarch)\nlibrary(forecast)\nlibrary(FinTS)\n\nx <- getSymbols(Symbols = 'V', \n           verbose = FALSE,\n           warnings = FALSE,\n           from =\"2008-01-03\", to = \"2021-12-31\",\n           auto.assign = FALSE)\nx.ret <- CalculateReturns(Cl(x), method=\"log\") |> \n  na.omit()\n\nx.ret |> \n  ggplot() +\n  geom_line(aes(x = Index, y = V.Close)) +\n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\n## Volatilidad Incondicional vs Condicional\n\nSe observa una alta volatilidad incondicional. Para todo el período de análisis, este indicador asciende a 0.019. Este tipo de analisis considera cada realización de igual manera, por lo que movimientos de precios que ocurrieron al principio de la serie tienen igual ponderación que aquellos movimientos que sucedieron en el pasado reciente.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx.ret |> \n  ggplot() +\n  geom_line(aes(x = Index, y = V.Close)) +\n  geom_hline(yintercept = sd(x.ret$V.Close), col = 'red', linewidth = 1.3) +\n  geom_hline(yintercept = -sd(x.ret$V.Close), col = 'red', linewidth = 1.3) +\n  theme_classic() \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n## EWMA\n\nUna alternativa más robusta es el uso de una medida de volatilidad que descuenta la ponderación en el tiempo.\n\n$$\n\\sigma_t^2 =(1-\\lambda)\\varepsilon_{t-1}^2+\\lambda\\sigma_{t-1}^2\n$$\n\nEn general, para datos diarios $\\lambda = 0.94$. A continuación se observa un gráfico donde se puede apreciar que la medida de volatilidad es mayor en aquellos periodos donde las variaciones de precios tienden a mostrar variaciones de mayor escala, y que la misma disminuye en periodos de mayor estabilidad de precios.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Specs\newma.spec <- ugarchspec(mean.model=list(armaOrder=c(1,1),\n                                        include.mean=FALSE),\n                        variance.model=list(model=\"iGARCH\"), \n                        fixed.pars=list(alpha1=1-0.94,\n                                        omega=0))\n# Fit\newma.fit <- ugarchfit(spec = ewma.spec,\n                      data = x.ret)\n\n# Plot\ndataToPlot <- cbind(residuals(ewma.fit), sigma(ewma.fit))\ncolnames(dataToPlot) <- c(\"Retornos\", \"EWMA\")\nplot.zoo(dataToPlot, main=\"Retornos Diarios\", col=\"blue\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n## GARCH\n\nLos modelos GARCH permiten capturar determinados rezagos de la varianza de la serie en cuestión, añadiendo mayor flexibilidad a la hora de modelar el comportamiento de la volatilidad. Propiamente, estos modelos se especifican como:\n\n$$\n\\sigma^2 = w +  \\alpha R_{t-1,t}^2 + \\beta \\sigma_{t-1,t}^2\n$$\n\nPara la estimación de estos modelos es necesario espeficicar un modelo ARIMA.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(2,1))\n  acf(x.ret)\n  pacf(x.ret)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nLos resultado de las pruebas de autocorrelación y autocorrelacion parcial sugieren el uso de un modelo ARMA(1,1). Más abajo se muestra el resultado de un modelo GARCH(1,1).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Specs\ngarch.spec <- ugarchspec()\n# Fit\ngarch.fit <- ugarchfit(spec = garch.spec,\n                      data = x.ret)\n\n# Plot\ndataToPlot <- cbind(residuals(garch.fit), sigma(garch.fit))\ncolnames(dataToPlot) <- c(\"Retornos\", \"GARCH\")\nplot.zoo(dataToPlot, main=\"Retornos Diarios\", col=\"blue\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n## EWMA vs GARCH\n\nAl comparar los resultado de las volatilidades de los modelos EWMA y GARCH(1,1) se puede apreciar que los resultados son similares (para el caso específico de esta serie). Se sugiere explorar otras versiones de la familia de modelos GARCH que logren capturar de mejor manera la volatilidad de esta serie.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nautoplot(merge(sigma(ewma.fit), sigma(garch.fit)), facet = NULL) + \n  ylab(\"Volatilidad Condicional\") +\n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n## El \"mejor\" modelo\n\nUna forma de buscar un mejor modelo GARCH es estimar diferentes versiones con distintos parámetros y luego escoger el mejor modelo basado en criterios de informacion (como el AIC).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Importa funciones\nsource('https://raw.githubusercontent.com/msperlin/GARCH-RAC/master/fcts/garch_fcts.R')\n\ntab_out <- do_arch_test(x = x.ret, max_lag = 5)\n\ndist_to_use <- c('norm','std','jsu') # see rugarch::ugarchspecs\nmodels_to_estimate <- c('sGARCH', 'eGARCH', 'gjrGARCH') # see rugarch::rugarchspec help for more\n\nout <- find_best_arch_model(x = x.ret, \n                            type_models = models_to_estimate,\n                            dist_to_use = dist_to_use,\n                            max_lag_AR = 1,\n                            max_lag_MA = 1,\n                            max_lag_ARCH = 1,\n                            max_lag_GARCH = 1)\n\n# tabla resumen con resultados\ntab_out <- out$tab_out\nbest_models <- c(tab_out$model_name[which.min(tab_out$AIC)],\n                 tab_out$model_name[which.min(tab_out$BIC)])\n\ntab_out |> \n  filter(!is.na(AIC)) |> \n  DT::datatable()\n```\n\n::: {.cell-output-display}\n```{=html}\n<div id=\"htmlwidget-b4015636d9abab7a791d\" style=\"width:100%;height:auto;\" class=\"datatables html-widget\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-b4015636d9abab7a791d\">{\"x\":{\"filter\":\"none\",\"vertical\":false,\"data\":[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\",\"13\",\"14\",\"15\",\"16\",\"17\",\"18\",\"19\",\"20\",\"21\",\"22\",\"23\",\"24\",\"25\",\"26\",\"27\",\"28\",\"29\",\"30\",\"31\",\"32\",\"33\",\"34\",\"35\",\"36\"],[0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1],[0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[-5.4781084858467,-5.48131941288025,-5.48113691073494,-5.48525323417146,-5.58138158239134,-5.58959365138357,-5.58889019962267,-5.59379193106024,-5.58198667457371,-5.59127367233333,-5.59038297128857,-5.59695274285348,-5.51106406606368,-5.51446759513042,-5.51429582067556,-5.51595402383952,-5.60246663832228,-5.61068528631709,-5.61012391890214,-5.61295317144233,-5.60513414127243,-5.61354383530331,-5.61289862731003,-5.61605299963997,-5.49166298417073,-5.49420230290601,-5.49410091018682,-5.49748235892327,-5.59187994431097,-5.5996128092979,-5.5990597973849,-5.60249296253976,-5.59386508161774,-5.60186502056091,-5.60124950100351,-5.60524402710424],[-5.47101865811306,-5.47245712821321,-5.47227462606789,-5.47461849257101,-5.5725192977243,-5.57895890978312,-5.57825545802222,-5.58138473252638,-5.57135193297326,-5.57886647379947,-5.57797577275471,-5.58277308738621,-5.50220178139663,-5.50383285352997,-5.50366107907511,-5.50354682530566,-5.59183189672183,-5.59827808778323,-5.59771672036827,-5.59877351597506,-5.59272694273857,-5.59936417983604,-5.59871897184277,-5.6001008872393,-5.48280069950368,-5.48356756130556,-5.48346616858637,-5.48507516038941,-5.58124520271052,-5.58720561076404,-5.58665259885104,-5.58831330707249,-5.58145788308388,-5.58768536509364,-5.58706984553624,-5.58929191470356],[\"sGARCH\",\"sGARCH\",\"sGARCH\",\"sGARCH\",\"sGARCH\",\"sGARCH\",\"sGARCH\",\"sGARCH\",\"sGARCH\",\"sGARCH\",\"sGARCH\",\"sGARCH\",\"eGARCH\",\"eGARCH\",\"eGARCH\",\"eGARCH\",\"eGARCH\",\"eGARCH\",\"eGARCH\",\"eGARCH\",\"eGARCH\",\"eGARCH\",\"eGARCH\",\"eGARCH\",\"gjrGARCH\",\"gjrGARCH\",\"gjrGARCH\",\"gjrGARCH\",\"gjrGARCH\",\"gjrGARCH\",\"gjrGARCH\",\"gjrGARCH\",\"gjrGARCH\",\"gjrGARCH\",\"gjrGARCH\",\"gjrGARCH\"],[\"norm\",\"norm\",\"norm\",\"norm\",\"std\",\"std\",\"std\",\"std\",\"jsu\",\"jsu\",\"jsu\",\"jsu\",\"norm\",\"norm\",\"norm\",\"norm\",\"std\",\"std\",\"std\",\"std\",\"jsu\",\"jsu\",\"jsu\",\"jsu\",\"norm\",\"norm\",\"norm\",\"norm\",\"std\",\"std\",\"std\",\"std\",\"jsu\",\"jsu\",\"jsu\",\"jsu\"],[\"ARMA(0,0)+sGARCH(1,1) norm\",\"ARMA(0,1)+sGARCH(1,1) norm\",\"ARMA(1,0)+sGARCH(1,1) norm\",\"ARMA(1,1)+sGARCH(1,1) norm\",\"ARMA(0,0)+sGARCH(1,1) std\",\"ARMA(0,1)+sGARCH(1,1) std\",\"ARMA(1,0)+sGARCH(1,1) std\",\"ARMA(1,1)+sGARCH(1,1) std\",\"ARMA(0,0)+sGARCH(1,1) jsu\",\"ARMA(0,1)+sGARCH(1,1) jsu\",\"ARMA(1,0)+sGARCH(1,1) jsu\",\"ARMA(1,1)+sGARCH(1,1) jsu\",\"ARMA(0,0)+eGARCH(1,1) norm\",\"ARMA(0,1)+eGARCH(1,1) norm\",\"ARMA(1,0)+eGARCH(1,1) norm\",\"ARMA(1,1)+eGARCH(1,1) norm\",\"ARMA(0,0)+eGARCH(1,1) std\",\"ARMA(0,1)+eGARCH(1,1) std\",\"ARMA(1,0)+eGARCH(1,1) std\",\"ARMA(1,1)+eGARCH(1,1) std\",\"ARMA(0,0)+eGARCH(1,1) jsu\",\"ARMA(0,1)+eGARCH(1,1) jsu\",\"ARMA(1,0)+eGARCH(1,1) jsu\",\"ARMA(1,1)+eGARCH(1,1) jsu\",\"ARMA(0,0)+gjrGARCH(1,1) norm\",\"ARMA(0,1)+gjrGARCH(1,1) norm\",\"ARMA(1,0)+gjrGARCH(1,1) norm\",\"ARMA(1,1)+gjrGARCH(1,1) norm\",\"ARMA(0,0)+gjrGARCH(1,1) std\",\"ARMA(0,1)+gjrGARCH(1,1) std\",\"ARMA(1,0)+gjrGARCH(1,1) std\",\"ARMA(1,1)+gjrGARCH(1,1) std\",\"ARMA(0,0)+gjrGARCH(1,1) jsu\",\"ARMA(0,1)+gjrGARCH(1,1) jsu\",\"ARMA(1,0)+gjrGARCH(1,1) jsu\",\"ARMA(1,1)+gjrGARCH(1,1) jsu\"]],\"container\":\"<table class=\\\"display\\\">\\n  <thead>\\n    <tr>\\n      <th> <\\/th>\\n      <th>lag_ar<\\/th>\\n      <th>lag_ma<\\/th>\\n      <th>lag_arch<\\/th>\\n      <th>lag_garch<\\/th>\\n      <th>AIC<\\/th>\\n      <th>BIC<\\/th>\\n      <th>type_model<\\/th>\\n      <th>type_dist<\\/th>\\n      <th>model_name<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"columnDefs\":[{\"className\":\"dt-right\",\"targets\":[1,2,3,4,5,6]},{\"orderable\":false,\"targets\":0}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n:::\n\n```{.r .cell-code}\n#print(tab_out)\n```\n:::\n\n\nLa tabla anterior muestra diferentes resultados de una batería de modelos. De este ejercicio se identifica que los modelos con menor criterio de informacion AIC y BIC son ARMA(1,1)+eGARCH(1,1) jsu, ARMA(1,1)+eGARCH(1,1) jsu. Utilizando esta especificación y los datos observados de las variaciones logarítmicas de precios obtenemos una mejor visión acerca de los riesgos de este instrumento.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbest_spec = ugarchspec(variance.model = list(model =  out$best_bic$type_model, \n                                             garchOrder = c(out$best_bic$lag_arch,\n                                                            out$best_bic$lag_garch)),\n                       mean.model = list(armaOrder = c(out$best_bic$lag_ar, \n                                                       out$best_bic$lag_ma)),\n                       distribution = out$best_bic$type_dist)\n\n# Fit\nmy_best_garch <- ugarchfit(spec = best_spec, \n                           data = x.ret)\n\n# Plot\nplot(my_best_garch, which=\"all\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nplease wait...calculating quantiles...\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n## Simulación de Monte Carlo\n\nCon el \"mejor\" modelo que describe el comportamiento de la volatilidad de los retornos es posible construir una simulación de Monte Carlo para generar *t* días en el futuro *n* cantidad de veces. Utilizando esto, es posible analizar la distribución de estas proyecciones.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndays.ahead = 365\nn.sim <- 1000\ngarch.sim <- matrix(nrow = days.ahead, ncol=n.sim)\n\nset.seed(123)\nfor(i in 1:n.sim){\n  p.sim = ugarchsim(my_best_garch, n.sim=days.ahead, startMethod=\"sample\")\n  garch.sim[,i] <- p.sim@simulation$seriesSim\n}\n\ngarch.sim <- as.data.frame(garch.sim)\n\n# Determinar los percentiles correspondientes\ngarch.sim$Q01 <- NA\ngarch.sim$Q05 <- NA\ngarch.sim$Q25 <- NA\ngarch.sim$Q75 <- NA\ngarch.sim$Q95 <- NA\ngarch.sim$Q99 <- NA\n\ngarch.sim$Q01 <- apply(garch.sim[,2:(ncol(garch.sim)-6)], FUN = function(x){quantile(na.omit(x),0.01)}, MARGIN = 1)\ngarch.sim$Q05 <- apply(garch.sim[,2:(ncol(garch.sim)-6)], FUN = function(x){quantile(na.omit(x),0.05)}, MARGIN = 1)\ngarch.sim$Q25 <- apply(garch.sim[,2:(ncol(garch.sim)-6)], FUN = function(x){quantile(na.omit(x),0.25)}, MARGIN = 1)\ngarch.sim$Q75 <- apply(garch.sim[,2:(ncol(garch.sim)-6)], FUN = function(x){quantile(na.omit(x),0.75)}, MARGIN = 1)\ngarch.sim$Q95 <- apply(garch.sim[,2:(ncol(garch.sim)-6)], FUN = function(x){quantile(na.omit(x),0.95)}, MARGIN = 1)\ngarch.sim$Q99 <- apply(garch.sim[,2:(ncol(garch.sim)-6)], FUN = function(x){quantile(na.omit(x),0.99)}, MARGIN = 1)\n\n# PRICE LEVEL FORECAST ----\n# Mapeo de predicciones de volatilidad por vía de la simulación en el precio\n# sim.dates <- seq(lubridate::ymd(last(index(x.ret))+1), \n#                  last(index(x.ret)) + (days.ahead), \n#                  by = \"days\")\nsim.dates <- seq(last(index(x.ret)) - (days.ahead), \n                 last(index(x.ret)) -1, \n                 by = \"days\")\n\n\n\ndf <- cbind(as.data.frame(sim.dates), garch.sim)\ndf <- as.xts(df[,-1], order.by=df$sim.dates)\ndf <- as.numeric(tail(Cl(x.ret),1)) * cumprod(1 + df)\n\ndf.combined <- rbind(Cl(x.ret))#,Cl(H1.oos))\ndf.combined <- merge(df.combined,df[,1:(ncol(df)-1)]) # do not merge the empty column\n\nlast.day <- index(tail(Cl(x.ret),1))\ndf.combined$Q01 <- as.numeric(apply(df.combined[,2:(ncol(df.combined)-1)], FUN = function(x){quantile(na.omit(x),0.01)}, MARGIN = 1))\ndf.combined$Q05 <- as.numeric(apply(df.combined[,2:(ncol(df.combined)-2)], FUN = function(x){quantile(na.omit(x),0.05)}, MARGIN = 1))\ndf.combined$Q25 <- as.numeric(apply(df.combined[,2:(ncol(df.combined)-3)], FUN = function(x){quantile(na.omit(x),0.25)}, MARGIN = 1))\ndf.combined$Q75 <- as.numeric(apply(df.combined[,2:(ncol(df.combined)-4)], FUN = function(x){quantile(na.omit(x),0.75)}, MARGIN = 1))\ndf.combined$Q95 <- as.numeric(apply(df.combined[,2:(ncol(df.combined)-5)], FUN = function(x){quantile(na.omit(x),0.95)}, MARGIN = 1))\ndf.combined$Q99 <- as.numeric(apply(df.combined[,2:(ncol(df.combined)-6)], FUN = function(x){quantile(na.omit(x),0.99)}, MARGIN = 1))\ndf.combined$mean <- as.numeric(apply(df.combined[,2:(ncol(df.combined)-7)], FUN = function(x){mean(na.omit(x))}, MARGIN = 1))\n\n#tail(df.combined[,c('Q01','Q05','Q25','mean','Q75','Q95','Q99')],15)\n\n#Visualizacion\npar(mfrow=c(1,1))\ngarch.sim.plot <- plot(Cl(df.combined[\"2018::\"]), ylim=c(min(na.omit(df.combined[\"2019::\",1]))*0.6,max(na.omit(df.combined[\"2019::\",1]))*1.3), \n                       main=paste0(\"Simulated \", \n                                   out$best_bic$type_model, \"(\", out$best_bic$lag_arch, \",\" ,out$best_bic$lag_garch, \") + ARMA(\",out$best_bic$lag_ar, \",\" ,out$best_bic$lag_ma,\") + \", out$best_bic$type_dist, \" distribution\"), grid.col=NA)\ngarch.sim.plot <- lines(df.combined[,2:(ncol(df.combined)-6)], col=alpha(\"grey\",0.5), on=1, lty=2, lwd=0.75)\ngarch.sim.plot <- lines(df.combined[,'Q01'], col=\"red\", on=1, lty=1, lwd=1)\ngarch.sim.plot <- lines(df.combined[,'Q05'], col=\"red\", on=1, lty=2, lwd=1.5)\ngarch.sim.plot <- lines(df.combined[,'Q25'], col=\"red\", on=1, lty=3, lwd=1.5)\ngarch.sim.plot <- lines(df.combined[,'mean'], col=\"black\", on=1, lty=2, lwd=1.5)\ngarch.sim.plot <- lines(df.combined[,'Q75'], col=\"blue\", on=1, lty=3, lwd=1.5)\ngarch.sim.plot <- lines(df.combined[,'Q95'], col=\"blue\", on=1, lty=2, lwd=1.5)\ngarch.sim.plot <- lines(df.combined[,'Q99'], col=\"blue\", on=1, lty=1, lwd=1)\ngarch.sim.plot <- lines(Cl(df.combined[\"2021::\"]), col=\"black\", on=1, lwd=1.25)\ngarch.sim.plot <- points(tail(df.combined[,'mean'],1), col=\"red\", pch=16)\ngarch.sim.plot\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../site_libs/htmlwidgets-1.5.4/htmlwidgets.js\"></script>\n<link href=\"../../site_libs/datatables-css-0.0.0/datatables-crosstalk.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/datatables-binding-0.26/datatables.js\"></script>\n<script src=\"../../site_libs/jquery-3.6.0/jquery-3.6.0.min.js\"></script>\n<link href=\"../../site_libs/dt-core-1.12.1/css/jquery.dataTables.min.css\" rel=\"stylesheet\" />\n<link href=\"../../site_libs/dt-core-1.12.1/css/jquery.dataTables.extra.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/dt-core-1.12.1/js/jquery.dataTables.min.js\"></script>\n<link href=\"../../site_libs/crosstalk-1.2.0/css/crosstalk.min.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/crosstalk-1.2.0/js/crosstalk.min.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}